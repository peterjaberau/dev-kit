import { useId, useMemo, useState } from "react";
import { Input } from "../../../components/ui/input";
import { Label } from "../../../components/ui/label";
import { Switch } from "../../../components/ui/switch";
import { useTranslation } from "../../../hooks/use-translation";
import { getArrayItemsSchema } from "../../../lib/schemaEditor";
import { cn } from "../../../lib/utils";
import type {
  ObjectJSONSchema,
  SchemaType,
} from "../../../types/jsonSchema";
import {
  isBooleanSchema,
  withObjectSchema,
} from "../../../types/jsonSchema";
import TypeDropdown from "../TypeDropdown";
import type { TypeEditorProps } from "../TypeEditor";
import TypeEditor from "../TypeEditor";

const ArrayEditor: React.FC<TypeEditorProps> = ({
  schema,
  readOnly = false,
  validationNode,
  onChange,
  depth = 0,
}) => {
  const t = useTranslation();
  const [minItems, setMinItems] = useState<number | undefined>(
    withObjectSchema(schema, (s) => s.minItems, undefined),
  );
  const [maxItems, setMaxItems] = useState<number | undefined>(
    withObjectSchema(schema, (s) => s.maxItems, undefined),
  );
  const [uniqueItems, setUniqueItems] = useState<boolean>(
    withObjectSchema(schema, (s) => s.uniqueItems || false, false),
  );

  const minItemsId = useId();
  const maxItemsId = useId();
  const uniqueItemsId = useId();

  // Get the array's item schema
  const itemsSchema = getArrayItemsSchema(schema) || { type: "string" };

  // Get the type of the array items
  const itemType = withObjectSchema(
    itemsSchema,
    (s) => (s.type || "string") as SchemaType,
    "string" as SchemaType,
  );

  // Handle validation settings change
  const handleValidationChange = () => {
    const propsToKeep = buildValidationProps();

    onChange(propsToKeep as ObjectJSONSchema);
  };

  /**
   * Builds and normalizes the JSON Schema validation properties for an array schema.
   *
   * This helper merges base schema constraints with optional overrides,
   * preserves the `items` schema when not explicitly provided,
   * and removes any undefined properties to produce a clean schema object.
   */
  const buildValidationProps = ({
    minItems: overrideMinItems,
    maxItems: overrideMaxItems,
    uniqueItems: overrideUniqueItems,
  }: {
    minItems?: number;
    maxItems?: number;
    uniqueItems?: boolean;
  } = {}) => {
    const validationProps: ObjectJSONSchema = {
      type: "array",
      ...(isBooleanSchema(schema) ? {} : schema),
      minItems: overrideMinItems || minItems,
      maxItems: overrideMaxItems || maxItems,
      uniqueItems: overrideUniqueItems || undefined,
    };

    // Keep the items schema
    if (validationProps.items === undefined && itemsSchema) {
      validationProps.items = itemsSchema;
    }

    // Clean up undefined values
    const propsToKeep: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(validationProps)) {
      if (value !== undefined) {
        propsToKeep[key] = value;
      }
    }

    return propsToKeep as ObjectJSONSchema;
  };

  // Handle item schema changes
  const handleItemSchemaChange = (updatedItemSchema: ObjectJSONSchema) => {
    const updatedSchema: ObjectJSONSchema = {
      type: "array",
      ...(isBooleanSchema(schema) ? {} : schema),
      items: updatedItemSchema,
    };

    onChange(updatedSchema);
  };

  const minMaxError = useMemo(
    () =>
      validationNode?.validation.errors?.find((err) => err.path[0] === "minmax")
        ?.message,
    [validationNode],
  );

  const minItemsError = useMemo(
    () =>
      validationNode?.validation.errors?.find(
        (err) => err.path[0] === "minItems",
      )?.message,
    [validationNode],
  );

  const maxItemsError = useMemo(
    () =>
      validationNode?.validation.errors?.find(
        (err) => err.path[0] === "maxItems",
      )?.message,
    [validationNode],
  );

  // @ts-ignore
  return (
    <div className="space-y-6">
      {/* Array validation settings */}
      {(!readOnly || !!maxItems || !!minItems) && (
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          {(!readOnly || !!minItems) && (
            <div className="space-y-2">
              <Label
                htmlFor={minItemsId}
                /*@ts-ignore*/
                className={(!!minMaxError || !!minItemsError) && "text-destructive"}
              >
                {t.arrayMinimumLabel}
              </Label>
              <Input
                id={minItemsId}
                type="number"
                min={0}
                value={minItems ?? ""}
                onChange={(e) => {
                  const value = e.target.value ? Number(e.target.value) : undefined
                  setMinItems(value)
                  // Don't update immediately to avoid too many rerenders
                }}
                onBlur={handleValidationChange}
                placeholder={t.arrayMinimumPlaceholder}
                className={cn("h-8", !!minMaxError && "border-destructive")}
              />
            </div>
          )}

          {(!readOnly || !!maxItems) && (
            <div className="space-y-2">
              <Label
                htmlFor={maxItemsId}
                /*@ts-ignore*/
                className={(!!minMaxError || !!maxItemsError) && "text-destructive"}
              >
                {t.arrayMaximumLabel}
              </Label>
              <Input
                id={maxItemsId}
                type="number"
                min={0}
                value={maxItems ?? ""}
                onChange={(e) => {
                  const value = e.target.value ? Number(e.target.value) : undefined
                  setMaxItems(value)
                  // Don't update immediately to avoid too many rerenders
                }}
                onBlur={handleValidationChange}
                placeholder={t.arrayMaximumPlaceholder}
                className={cn("h-8", !!minMaxError && "border-destructive")}
              />
            </div>
          )}
          {(!!minMaxError || !!minItemsError || !!maxItemsError) && (
            <div className="text-destructive whitespace-pre-line text-xs italic md:col-span-2">
              {[minMaxError, minItemsError ?? maxItemsError].filter(Boolean).join("\n")}
            </div>
          )}
        </div>
      )}

      {(!readOnly || !!uniqueItems) && (
        <div className="flex items-center space-x-2">
          <Switch
            id={uniqueItemsId}
            checked={uniqueItems}
            onCheckedChange={(checked) => {
              setUniqueItems(checked)
              onChange(buildValidationProps({ uniqueItems: checked }))
            }}
          />
          <Label htmlFor={uniqueItemsId} className="cursor-pointer">
            {t.arrayForceUniqueItemsLabel}
          </Label>
        </div>
      )}

      {/* Array item type editor */}
      <div
        className={cn(
          "border-border/40 space-y-2 pt-4",
          !readOnly || !!minItems || !!maxItems || !!uniqueItems ? "border-t" : null,
        )}
      >
        <div className="mb-4 flex items-center justify-between">
          <Label>{t.arrayItemTypeLabel}</Label>
          <TypeDropdown
            readOnly={readOnly}
            value={itemType}
            onChange={(newType) => {
              handleItemSchemaChange({
                ...withObjectSchema(itemsSchema, (s) => s, {}),
                type: newType,
              })
            }}
          />
        </div>

        {/* Item schema editor */}
        <TypeEditor
          readOnly={readOnly}
          schema={itemsSchema}
          validationNode={validationNode}
          onChange={handleItemSchemaChange}
          depth={depth + 1}
        />
      </div>
    </div>
  )
};

export default ArrayEditor;
