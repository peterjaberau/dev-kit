// constants.ts
export const PANEL_POSITIONS = ["left", "right", "bottom"] as const


//Panel.tsx
import React, { useRef } from "react"
import classNames from "classnames"
import { upperFirst } from "lodash"

import { useResizablePanel, type UseResizablePanelParameters } from "./useResizablePanel"
import { getDisplayStyle, getPositionStyle } from "./utils"

import "./panel.css"

export interface PanelProps extends Omit<UseResizablePanelParameters, "panelRef" | "handleRef"> {
  isFloating?: boolean
  handleClassName?: string
  className?: string
  id?: string
  ariaLabel: string
}

export const Panel: React.FunctionComponent<React.PropsWithChildren<PanelProps>> = ({
  children,
  className,
  defaultSize = 200,
  storageKey,
  position = "bottom",
  isFloating = false,
  handleClassName,
  minSize,
  maxSize,
  ariaLabel,
  onResize,
}) => {
  const handleReference = useRef<HTMLDivElement | null>(null)
  const panelReference = useRef<HTMLDivElement | null>(null)

  const { panelSize, isResizing } = useResizablePanel({
    position,
    panelRef: panelReference,
    handleRef: handleReference,
    storageKey,
    defaultSize,
    minSize,
    maxSize,
    onResize,
  })

  return (
    <div
      style={{ [position === "bottom" ? "height" : "width"]: `${panelSize}px` }}
      className={classNames(className, "panel", getPositionStyle({ position }), getDisplayStyle({ isFloating }))}
      ref={panelReference}
      role="region"
      aria-label={ariaLabel}
    >
      <div
        ref={handleReference}
        role="presentation"
        className={classNames(
          "handle",
          `handle${upperFirst(position)}`,
          handleClassName,
          isResizing && "handleResizing",
        )}
      />
      {children}
    </div>
  )
}

//useResizablePanel.ts
import type React from "react"
import { useEffect, useLayoutEffect, useRef, useState } from "react"
import type { PANEL_POSITIONS } from "./constants"

const STORAGE_KEY_PREFIX = "ResizePanel:"

const savePanelSize = (storageKey: string | null | undefined, size: number): void => {
  if (storageKey) {
    localStorage.setItem(`${STORAGE_KEY_PREFIX}${storageKey}`, String(size))
  }
}

const isLessThanOrEqualMax = (size: number, maxSize?: number): boolean => maxSize == null || size <= maxSize

const isGreaterThanOrEqualMin = (size: number, minSize?: number): boolean => minSize == null || size >= minSize

const getCachedPanelSize = (
  storageKey: string | undefined | null,
  defaultSize: number,
  maxSize?: number,
  minSize?: number,
): number => {
  if (!storageKey) return defaultSize

  const cached = localStorage.getItem(`${STORAGE_KEY_PREFIX}${storageKey}`)
  const size = cached ? parseInt(cached, 10) : NaN

  if (Number.isFinite(size) && isLessThanOrEqualMax(size, maxSize) && isGreaterThanOrEqualMin(size, minSize)) {
    return size
  }

  return defaultSize
}

export interface PanelResizerState {
  panelSize: number
  isResizing: boolean
}

export interface UseResizablePanelParameters {
  position?: (typeof PANEL_POSITIONS)[number]
  storageKey?: string | null
  defaultSize?: number
  minSize?: number
  maxSize?: number
  panelRef: React.MutableRefObject<HTMLDivElement | null>
  handleRef: React.MutableRefObject<HTMLDivElement | null>
  onResize?: (size: number) => void
}

export const useResizablePanel = ({
  defaultSize = 250,
  handleRef,
  panelRef,
  position,
  storageKey,
  maxSize,
  minSize,
  onResize,
}: UseResizablePanelParameters): PanelResizerState => {
  const [isResizing, setResizing] = useState(false)
  const [panelSize, setPanelSize] = useState(defaultSize)
  const debounceTimer = useRef<number | null>(null)

  useLayoutEffect(() => {
    const size = getCachedPanelSize(storageKey, defaultSize, maxSize, minSize)
    setPanelSize(size)
    onResize?.(size)
  }, [storageKey, defaultSize, maxSize, minSize, onResize])

  useEffect(() => {
    if (!storageKey) return

    if (debounceTimer.current) {
      clearTimeout(debounceTimer.current)
    }

    debounceTimer.current = window.setTimeout(() => {
      savePanelSize(storageKey, panelSize)
    }, 250)

    return () => {
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current)
      }
    }
  }, [panelSize, storageKey])

  useEffect(() => {
    const handle = handleRef.current
    const panel = panelRef.current
    if (!handle || !panel) return

    const onMouseMove = (event: MouseEvent): void => {
      event.preventDefault()

      let size =
        position !== "bottom"
          ? position === "left"
            ? event.pageX - panel.getBoundingClientRect().left
            : panel.getBoundingClientRect().right - event.pageX
          : panel.getBoundingClientRect().bottom - event.pageY

      if (event.shiftKey) {
        size = Math.ceil(size / 20) * 20
      }

      if (isLessThanOrEqualMax(size, maxSize) && isGreaterThanOrEqualMin(size, minSize)) {
        setPanelSize(size)
        onResize?.(size)
      }
    }

    const onMouseUp = (event: Event): void => {
      event.preventDefault()
      setResizing(false)
      document.removeEventListener("mousemove", onMouseMove)
      document.removeEventListener("mouseup", onMouseUp)
    }

    const onMouseDown = (event: MouseEvent): void => {
      event.preventDefault()
      setResizing(true)
      document.addEventListener("mousemove", onMouseMove)
      document.addEventListener("mouseup", onMouseUp)
    }

    handle.addEventListener("mousedown", onMouseDown)

    return () => {
      handle.removeEventListener("mousedown", onMouseDown)
    }
  }, [panelRef, handleRef, position, maxSize, minSize, onResize])

  return { panelSize, isResizing }
}

//utils.ts
// utils.ts
import classNames from "classnames"
import { upperFirst } from "lodash"
import type { PANEL_POSITIONS } from "./constants"

interface GetDisplayStyleParameters {
  isFloating?: boolean
}

export const getDisplayStyle = ({ isFloating }: GetDisplayStyleParameters): string =>
  classNames(`panel${upperFirst(isFloating ? "Fixed" : "Relative")}`)

interface GetPositionStyleParameters {
  position?: (typeof PANEL_POSITIONS)[number]
}

export const getPositionStyle = ({ position }: GetPositionStyleParameters): string =>
  classNames(`panel${upperFirst(position)}`)

// panel.css
/* Panel.css */
.panel {
    --panel-handle-size: 0.35rem;
    --panel-handle-bg-color: var(--border-muted);
    --panel-handle-resizing-bg-color: var(--border-color);
    overflow: visible;
    bottom: 0;
}

.panelBottom {
    left: 0;
    right: 0;
}

.panelRight,
.panelLeft {
    height: 100%;
    top: 0;
}

.panelLeft {
    left: 0;
}

.panelRight {
    right: 0;
}

.panelFixed {
    position: fixed;
}

.panelRelative {
    position: relative;
    flex: 0 0 auto;
}

.handle {
    position: absolute;
    opacity: 0;
    user-select: none;
    z-index: 1;
    flex-shrink: 0;
}

.handleRight,
.handleLeft {
    width: var(--panel-handle-size);
    cursor: ew-resize;
    top: 0;
    bottom: 0;
}

.handleRight {
    left: calc(-0.5 * var(--panel-handle-size));
}

.handleLeft {
    right: calc(-0.5 * var(--panel-handle-size));
}

.handleBottom {
    height: var(--panel-handle-size);
    top: calc(-0.5 * var(--panel-handle-size));
    cursor: ns-resize;
    left: 0;
    right: 0;
}

.handle:hover {
    opacity: 0.5;
    background-color: var(--border-color);
}

.handleResizing,
.handleResizing:hover {
    opacity: 1;
    background-color: var(--panel-handle-resizing-bg-color);
}